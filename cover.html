
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>gophermart: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/MxTrap/gophermart/cmd/gophermart/main.go (0.0%)</option>
				
				<option value="file1">github.com/MxTrap/gophermart/config/config.go (0.0%)</option>
				
				<option value="file2">github.com/MxTrap/gophermart/internal/gophermart/app/app.go (0.0%)</option>
				
				<option value="file3">github.com/MxTrap/gophermart/internal/gophermart/controller/http/controller.go (94.4%)</option>
				
				<option value="file4">github.com/MxTrap/gophermart/internal/gophermart/controller/http/handlers/auth/auth.go (97.3%)</option>
				
				<option value="file5">github.com/MxTrap/gophermart/internal/gophermart/controller/http/handlers/balance/balance.go (78.9%)</option>
				
				<option value="file6">github.com/MxTrap/gophermart/internal/gophermart/controller/http/handlers/order/order.go (84.3%)</option>
				
				<option value="file7">github.com/MxTrap/gophermart/internal/gophermart/controller/http/handlers/withdrawal/withdrawal.go (75.0%)</option>
				
				<option value="file8">github.com/MxTrap/gophermart/internal/gophermart/controller/http/middlewares/authorization.go (100.0%)</option>
				
				<option value="file9">github.com/MxTrap/gophermart/internal/gophermart/controller/http/middlewares/logger.go (0.0%)</option>
				
				<option value="file10">github.com/MxTrap/gophermart/internal/gophermart/controller/http/utils/get_user_id.go (100.0%)</option>
				
				<option value="file11">github.com/MxTrap/gophermart/internal/gophermart/migrator/migrator.go (0.0%)</option>
				
				<option value="file12">github.com/MxTrap/gophermart/internal/gophermart/mocks/mock_balance_order_repository.go (0.0%)</option>
				
				<option value="file13">github.com/MxTrap/gophermart/internal/gophermart/mocks/mock_balance_repository.go (73.9%)</option>
				
				<option value="file14">github.com/MxTrap/gophermart/internal/gophermart/mocks/mock_balance_withdrawal_repository.go (100.0%)</option>
				
				<option value="file15">github.com/MxTrap/gophermart/internal/gophermart/mocks/mock_db.go (100.0%)</option>
				
				<option value="file16">github.com/MxTrap/gophermart/internal/gophermart/mocks/mock_order_repository.go (100.0%)</option>
				
				<option value="file17">github.com/MxTrap/gophermart/internal/gophermart/mocks/mock_rows.go (0.0%)</option>
				
				<option value="file18">github.com/MxTrap/gophermart/internal/gophermart/mocks/mock_storage_service.go (57.1%)</option>
				
				<option value="file19">github.com/MxTrap/gophermart/internal/gophermart/mocks/mock_tx.go (26.7%)</option>
				
				<option value="file20">github.com/MxTrap/gophermart/internal/gophermart/mocks/mock_user_repository.go (0.0%)</option>
				
				<option value="file21">github.com/MxTrap/gophermart/internal/gophermart/mocks/mock_withdrawal_repository.go (64.7%)</option>
				
				<option value="file22">github.com/MxTrap/gophermart/internal/gophermart/repository/postgres/balance/balance.go (0.0%)</option>
				
				<option value="file23">github.com/MxTrap/gophermart/internal/gophermart/repository/postgres/combined/balance_order.go (95.0%)</option>
				
				<option value="file24">github.com/MxTrap/gophermart/internal/gophermart/repository/postgres/combined/balance_withdrawn.go (0.0%)</option>
				
				<option value="file25">github.com/MxTrap/gophermart/internal/gophermart/repository/postgres/order/order.go (0.0%)</option>
				
				<option value="file26">github.com/MxTrap/gophermart/internal/gophermart/repository/postgres/storage.go (0.0%)</option>
				
				<option value="file27">github.com/MxTrap/gophermart/internal/gophermart/repository/postgres/user/user.go (0.0%)</option>
				
				<option value="file28">github.com/MxTrap/gophermart/internal/gophermart/repository/postgres/withdrawal/withdrawal.go (0.0%)</option>
				
				<option value="file29">github.com/MxTrap/gophermart/internal/gophermart/repository/repository_err.go (100.0%)</option>
				
				<option value="file30">github.com/MxTrap/gophermart/internal/gophermart/services/accrual/accrual.go (100.0%)</option>
				
				<option value="file31">github.com/MxTrap/gophermart/internal/gophermart/services/auth/auth.go (95.1%)</option>
				
				<option value="file32">github.com/MxTrap/gophermart/internal/gophermart/services/balance/balance.go (100.0%)</option>
				
				<option value="file33">github.com/MxTrap/gophermart/internal/gophermart/services/jwt/jwt.go (89.3%)</option>
				
				<option value="file34">github.com/MxTrap/gophermart/internal/gophermart/services/order/order.go (100.0%)</option>
				
				<option value="file35">github.com/MxTrap/gophermart/internal/gophermart/services/orderworker/mock_services.go (100.0%)</option>
				
				<option value="file36">github.com/MxTrap/gophermart/internal/gophermart/services/orderworker/order_worker.go (92.1%)</option>
				
				<option value="file37">github.com/MxTrap/gophermart/internal/gophermart/services/storage/storage.go (100.0%)</option>
				
				<option value="file38">github.com/MxTrap/gophermart/internal/gophermart/services/withdrawal/withdrawal.go (100.0%)</option>
				
				<option value="file39">github.com/MxTrap/gophermart/internal/utils/project_path.go (0.0%)</option>
				
				<option value="file40">github.com/MxTrap/gophermart/internal/utils/validate_number.go (91.7%)</option>
				
				<option value="file41">github.com/MxTrap/gophermart/logger/logger.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "context"
        "os"
        "os/signal"
        "syscall"

        "github.com/MxTrap/gophermart/config"
        "github.com/MxTrap/gophermart/internal/gophermart/app"
        "github.com/MxTrap/gophermart/logger"
)

func main() <span class="cov0" title="0">{
        ctx, cancel := context.WithCancel(context.Background())
        log := logger.NewLogger()
        cfg, err := config.NewConfig()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        <span class="cov0" title="0">newApp, err := app.NewApp(ctx, log, cfg)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        <span class="cov0" title="0">go newApp.Run(ctx)

        sig := make(chan os.Signal, 1)
        signal.Notify(sig, syscall.SIGHUP, syscall.SIGINT, syscall.SIGTERM, syscall.SIGQUIT)

        &lt;-sig
        err = newApp.Stop(ctx)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        <span class="cov0" title="0">cancel()</span>

}
</pre>
		
		<pre class="file" id="file1" style="display: none">package config

import (
        "flag"

        "github.com/caarlos0/env"
)

type Config struct {
        HTTPAdress     string `env:"RUN_ADDRESS"`
        DatabaseDSN    string `env:"DATABASE_URI"`
        AccrualAddress string `env:"ACCRUAL_SYSTEM_ADDRESS"`
}

func NewConfig() (*Config, error) <span class="cov0" title="0">{
        httpAddr := flag.String("a", "", "host and port http")
        databaseDSN := flag.String("d", "", "database DSN")
        accrualAddr := flag.String("r", "", "address of the accrual calculation system")
        flag.Parse()

        cfg := &amp;Config{
                HTTPAdress:     *httpAddr,
                DatabaseDSN:    *databaseDSN,
                AccrualAddress: *accrualAddr,
        }

        err := env.Parse(cfg)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return cfg, nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package app

import (
        "context"
        authhandler "github.com/MxTrap/gophermart/internal/gophermart/controller/http/handlers/auth"
        balancehandler "github.com/MxTrap/gophermart/internal/gophermart/controller/http/handlers/balance"
        orderhandler "github.com/MxTrap/gophermart/internal/gophermart/controller/http/handlers/order"
        withdrawalhandler "github.com/MxTrap/gophermart/internal/gophermart/controller/http/handlers/withdrawal"
        "github.com/MxTrap/gophermart/internal/gophermart/services/accrual"
        "github.com/MxTrap/gophermart/internal/gophermart/services/auth"
        "github.com/MxTrap/gophermart/internal/gophermart/services/balance"
        "github.com/MxTrap/gophermart/internal/gophermart/services/jwt"
        "github.com/MxTrap/gophermart/internal/gophermart/services/order"
        "github.com/MxTrap/gophermart/internal/gophermart/services/orderworker"
        "github.com/MxTrap/gophermart/internal/gophermart/services/storage"
        "github.com/MxTrap/gophermart/internal/gophermart/services/withdrawal"
        "github.com/go-chi/chi/v5/middleware"
        "time"

        "github.com/MxTrap/gophermart/config"

        "github.com/MxTrap/gophermart/internal/gophermart/controller/http"
        "github.com/MxTrap/gophermart/internal/gophermart/controller/http/middlewares"
        "github.com/MxTrap/gophermart/internal/gophermart/migrator"
        "github.com/MxTrap/gophermart/internal/gophermart/repository/postgres"
        balancerepo "github.com/MxTrap/gophermart/internal/gophermart/repository/postgres/balance"
        "github.com/MxTrap/gophermart/internal/gophermart/repository/postgres/combined"
        orderrepo "github.com/MxTrap/gophermart/internal/gophermart/repository/postgres/order"
        userrepo "github.com/MxTrap/gophermart/internal/gophermart/repository/postgres/user"
        withdrawalrepo "github.com/MxTrap/gophermart/internal/gophermart/repository/postgres/withdrawal"
        "github.com/MxTrap/gophermart/logger"
)

type App struct {
        pgStorage      *postgres.Storage
        httpController *http.Controller
        orderWorker    *orderworker.OrderWorkerService
        logger         *logger.Logger
}

func NewApp(ctx context.Context, log *logger.Logger, cfg *config.Config) (*App, error) <span class="cov0" title="0">{
        postgresStorage, err := postgres.NewPostgresStorage(ctx, cfg.DatabaseDSN)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">mgrtr, err := migrator.NewMigrator(postgresStorage.Pool)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">err = mgrtr.InitializeDB()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">userRepo := userrepo.NewUserRepository(postgresStorage.Pool)
        orderRepo := orderrepo.NewOrderRepository(postgresStorage.Pool)
        balanceRepo := balancerepo.NewBalanceRepository(postgresStorage.Pool)
        withdrawalRepo := withdrawalrepo.NewWithdrawnRepo(postgresStorage.Pool)
        orderBalanceRepo := combined.NewOrderBalanceRepo(postgresStorage.Pool, orderRepo, balanceRepo)
        balanceWithdrawalRepo := combined.NewBalanceWithdrawnRepo(postgresStorage.Pool, balanceRepo, withdrawalRepo)

        storageSvc := storage.NewStorageService()
        jwtSvc := jwt.NewJWTService("very secret")
        orderSvc := order.NewOrderService(log, storageSvc, orderRepo)
        balanceSvc := balance.NewBalanceService(log, balanceRepo)
        accrualSvc := accrual.NewAccrualService(log, cfg.AccrualAddress)
        withdrawalSvc := withdrawal.NewWithdrawalService(log, balanceWithdrawalRepo, withdrawalRepo)
        authSvc := auth.NewAuthService(log, userRepo, jwtSvc, 15*time.Hour)
        orderWorkerSvc := orderworker.NewOrderWorkerService(log, accrualSvc, storageSvc, orderBalanceRepo)

        httpController := http.NewController(cfg.HTTPAdress)
        httpController.RegisterMiddlewares(
                middlewares.LoggerMiddleware(log),
                middleware.Compress(5, "application/json"),
        )

        authMiddleware := middlewares.NewAuhtorizationMiddleware(jwtSvc)

        authHandler := authhandler.NewAuthHandler(authSvc)
        ordersHandler := orderhandler.NewOrdersHandler(authMiddleware, orderSvc)
        balanceHandler := balancehandler.NewBalanceHandler(authMiddleware, balanceSvc, withdrawalSvc)
        withdrawalHandler := withdrawalhandler.NewWithdrawalHandler(authMiddleware, withdrawalSvc)

        httpController.AddHandler("/user", authHandler, ordersHandler, balanceHandler, withdrawalHandler)

        return &amp;App{
                pgStorage:      postgresStorage,
                httpController: httpController,
                orderWorker:    orderWorkerSvc,
                logger:         log,
        }, nil</span>
}

func (a *App) Run(ctx context.Context) <span class="cov0" title="0">{
        go func() </span><span class="cov0" title="0">{
                err := a.httpController.Start()
                if err != nil </span><span class="cov0" title="0">{
                        a.logger.Fatal(err)
                }</span>
        }()

        <span class="cov0" title="0">go a.orderWorker.Run(ctx)
        a.logger.Info("App started")</span>
}

func (a *App) Stop(ctx context.Context) error <span class="cov0" title="0">{
        err := a.httpController.Stop(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">a.pgStorage.Stop()
        a.logger.Info("App stopped")

        return nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package http

import (
        "context"
        "net/http"

        "github.com/go-chi/chi/v5"
)

type Controller struct {
        router   chi.Router
        server   *http.Server
        host     string
        handlers map[string][]func(chi.Router)
}

func NewController(host string) *Controller <span class="cov8" title="1">{
        r := chi.NewRouter()

        return &amp;Controller{
                router:   r,
                host:     host,
                handlers: make(map[string][]func(chi.Router)),
        }
}</span>

func (c *Controller) RegisterMiddlewares(middlewares ...func(http.Handler) http.Handler) <span class="cov8" title="1">{
        for _, middleware := range middlewares </span><span class="cov8" title="1">{
                c.router.Use(middleware)
        }</span>
}

func (c *Controller) AddHandler(path string, group ...func(chi.Router)) <span class="cov8" title="1">{
        if val, ok := c.handlers[path]; ok </span><span class="cov8" title="1">{
                val = append(val, group...)
                c.handlers[path] = val
                return
        }</span>
        <span class="cov8" title="1">c.handlers[path] = group</span>
}

func (c *Controller) registerHandlers() <span class="cov8" title="1">{
        c.router.Route("/api", func(r chi.Router) </span><span class="cov8" title="1">{
                for path, group := range c.handlers </span><span class="cov8" title="1">{
                        r.Route(path, func(r chi.Router) </span><span class="cov8" title="1">{
                                for _, handler := range group </span><span class="cov8" title="1">{
                                        handler(r)
                                }</span>
                        })
                }
        })
}

func (c *Controller) Start() error <span class="cov8" title="1">{
        c.server = &amp;http.Server{
                Addr:    c.host,
                Handler: c.router,
        }
        c.registerHandlers()
        return c.server.ListenAndServe()
}</span>

func (c *Controller) Stop(ctx context.Context) error <span class="cov0" title="0">{
        return c.server.Shutdown(ctx)
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package auth

import (
        "context"
        "encoding/json"
        "errors"
        "io"
        "net/http"

        "github.com/MxTrap/gophermart/internal/gophermart/common"
        "github.com/MxTrap/gophermart/internal/gophermart/entity"

        "github.com/go-chi/chi/v5"
)

type authService interface {
        Login(ctx context.Context, user entity.User) (entity.Token, error)
        RegisterNewUser(ctx context.Context, user entity.User) (entity.Token, error)
}

type handler struct {
        service authService
}

type TokenDto struct {
        Token string `json:"access_token"`
}

func NewAuthHandler(service authService) func(chi.Router) <span class="cov8" title="1">{
        h := &amp;handler{service: service}
        return func(r chi.Router) </span><span class="cov8" title="1">{
                r.Post("/login", h.LoginHandler)
                r.Post("/register", h.RegisterHandler)
        }</span>
}

func (h *handler) readUser(r *http.Request) (entity.User, error) <span class="cov8" title="1">{
        var user entity.User

        body, err := io.ReadAll(r.Body)
        if err != nil </span><span class="cov0" title="0">{
                return user, err
        }</span>

        <span class="cov8" title="1">if err := json.Unmarshal(body, &amp;user); err != nil </span><span class="cov8" title="1">{
                return user, err
        }</span>
        <span class="cov8" title="1">return user, nil</span>
}

func (h *handler) sendTokens(w http.ResponseWriter, token entity.Token) <span class="cov8" title="1">{
        w.Header().Set("Authorization", string(token))
        w.WriteHeader(http.StatusOK)
}</span>

func (h *handler) LoginHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        user, err := h.readUser(r)
        if err != nil </span><span class="cov8" title="1">{
                w.WriteHeader(http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">tokens, err := h.service.Login(r.Context(), user)
        if err == nil </span><span class="cov8" title="1">{
                h.sendTokens(w, tokens)
                return
        }</span>

        <span class="cov8" title="1">if errors.Is(err, common.ErrInvalidCredentials) </span><span class="cov8" title="1">{
                w.WriteHeader(http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">w.WriteHeader(http.StatusInternalServerError)</span>
}

func (h *handler) RegisterHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        user, err := h.readUser(r)
        if err != nil </span><span class="cov8" title="1">{
                w.WriteHeader(http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">tokens, err := h.service.RegisterNewUser(r.Context(), user)
        if err == nil </span><span class="cov8" title="1">{
                h.sendTokens(w, tokens)
                return
        }</span>

        <span class="cov8" title="1">if errors.Is(err, common.ErrUserAlreadyExist) </span><span class="cov8" title="1">{
                w.WriteHeader(http.StatusConflict)
                return
        }</span>

        <span class="cov8" title="1">w.WriteHeader(http.StatusInternalServerError)</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package balance

import (
        "context"
        "encoding/json"
        "errors"
        "io"
        "net/http"

        "github.com/MxTrap/gophermart/internal/gophermart/common"
        "github.com/MxTrap/gophermart/internal/gophermart/controller/http/utils"
        "github.com/MxTrap/gophermart/internal/gophermart/entity"

        "github.com/go-chi/chi/v5"
        "github.com/go-chi/render"
)

type balanceService interface {
        Get(ctx context.Context, userID int64) (entity.Balance, error)
}

type withdrawalService interface {
        Withdraw(ctx context.Context, userID int64, withdrawal entity.Withdrawal) error
}

type authMiddleware interface {
        Validate(next http.Handler) http.Handler
}

type balanceHandler struct {
        balanceSvc    balanceService
        withdrawalSvc withdrawalService
}

func NewBalanceHandler(
        middleware authMiddleware,
        balanceSvc balanceService,
        withdrawalSvc withdrawalService,
) func(chi.Router) <span class="cov0" title="0">{
        h := &amp;balanceHandler{
                balanceSvc:    balanceSvc,
                withdrawalSvc: withdrawalSvc,
        }
        return func(r chi.Router) </span><span class="cov0" title="0">{
                r.Route("/balance", func(r chi.Router) </span><span class="cov0" title="0">{
                        r.Use(middleware.Validate)
                        r.Post("/withdraw", h.Withdraw)
                        r.Get("/", h.GetBalance)
                }</span>)

        }
}

func (h *balanceHandler) GetBalance(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        userID, err := utils.GetUserID(r.Context())
        if err != nil </span><span class="cov8" title="1">{
                w.WriteHeader(http.StatusUnauthorized)
                return
        }</span>

        <span class="cov8" title="1">balance, err := h.balanceSvc.Get(r.Context(), userID)
        if err != nil </span><span class="cov8" title="1">{
                w.WriteHeader(http.StatusInternalServerError)
        }</span>

        <span class="cov8" title="1">balanceDTO := struct {
                Current   float32 `json:"current"`
                Withdrawn float32 `json:"withdrawn"`
        }{Current: balance.Balance, Withdrawn: balance.Withdrawn}

        render.JSON(w, r, balanceDTO)</span>
}

func (h *balanceHandler) Withdraw(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        userID, err := utils.GetUserID(r.Context())
        if err != nil </span><span class="cov8" title="1">{
                w.WriteHeader(http.StatusUnauthorized)
                return
        }</span>

        <span class="cov8" title="1">var withdrawal entity.Withdrawal

        body, err := io.ReadAll(r.Body)
        if err != nil </span><span class="cov0" title="0">{
                w.WriteHeader(http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">if err := json.Unmarshal(body, &amp;withdrawal); err != nil </span><span class="cov8" title="1">{
                w.WriteHeader(http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">err = h.withdrawalSvc.Withdraw(r.Context(), userID, withdrawal)
        if err == nil </span><span class="cov8" title="1">{
                w.WriteHeader(http.StatusOK)
                return
        }</span>

        <span class="cov8" title="1">if errors.Is(err, common.ErrInsufficientBalance) </span><span class="cov8" title="1">{
                w.WriteHeader(http.StatusPaymentRequired)
                return
        }</span>

        <span class="cov8" title="1">if errors.Is(err, common.ErrInvalidOrderNumber) </span><span class="cov8" title="1">{
                w.WriteHeader(http.StatusUnprocessableEntity)
                return
        }</span>

        <span class="cov8" title="1">w.WriteHeader(http.StatusInternalServerError)</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package order

import (
        "context"
        "errors"
        "io"
        "net/http"
        "time"

        "github.com/MxTrap/gophermart/internal/gophermart/common"
        "github.com/MxTrap/gophermart/internal/gophermart/controller/http/utils"
        "github.com/MxTrap/gophermart/internal/gophermart/entity"
        "github.com/go-chi/chi/v5"
        "github.com/go-chi/render"
)

type orderService interface {
        SaveOrder(ctx context.Context, order entity.Order) error
        GetAll(ctx context.Context, userID int64) ([]entity.Order, error)
}
type authMiddleware interface {
        Validate(next http.Handler) http.Handler
}

type orderHandler struct {
        service orderService
}

func NewOrdersHandler(middleware authMiddleware, service orderService) func(chi.Router) <span class="cov0" title="0">{
        h := &amp;orderHandler{
                service: service,
        }
        return func(r chi.Router) </span><span class="cov0" title="0">{
                r.Route("/orders", func(r chi.Router) </span><span class="cov0" title="0">{
                        r.Use(middleware.Validate)
                        r.Post("/", h.SaveOrderHandler)
                        r.Get("/", h.GetAllHandler)
                }</span>)

        }
}

func (h *orderHandler) SaveOrderHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if r.Header.Get("Content-Type") != "text/plain" </span><span class="cov8" title="1">{
                w.WriteHeader(http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">userID, err := utils.GetUserID(r.Context())
        if err != nil </span><span class="cov8" title="1">{
                w.WriteHeader(http.StatusUnauthorized)
                return
        }</span>

        <span class="cov8" title="1">body, err := io.ReadAll(r.Body)
        if err != nil </span><span class="cov0" title="0">{
                w.WriteHeader(http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">if len(string(body)) == 0 </span><span class="cov8" title="1">{
                w.WriteHeader(http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">order := entity.Order{UserID: userID, Number: string(body)}

        err = h.service.SaveOrder(r.Context(), order)

        if err == nil </span><span class="cov8" title="1">{
                w.WriteHeader(http.StatusAccepted)
                return
        }</span>

        <span class="cov8" title="1">if errors.Is(err, common.ErrOrderAlreadyExist) </span><span class="cov8" title="1">{
                w.WriteHeader(http.StatusOK)
                return
        }</span>

        <span class="cov8" title="1">if errors.Is(err, common.ErrOrderRegisteredByAnother) </span><span class="cov8" title="1">{
                w.WriteHeader(http.StatusConflict)
                return
        }</span>

        <span class="cov8" title="1">if errors.Is(err, common.ErrInvalidOrderNumber) </span><span class="cov8" title="1">{
                w.WriteHeader(http.StatusUnprocessableEntity)
                return
        }</span>

        <span class="cov8" title="1">w.WriteHeader(http.StatusInternalServerError)</span>
}

type orderDTO struct {
        Number     string   `json:"number"`
        Status     string   `json:"status"`
        Accrual    *float32 `json:"accrual,omitempty"`
        UploadedAt string   `json:"uploaded_at"`
}

func (*orderHandler) mapOrderToDTO(o entity.Order) orderDTO <span class="cov8" title="1">{
        return orderDTO{
                Number:     o.Number,
                Status:     o.Status,
                Accrual:    o.Accrual,
                UploadedAt: o.UploadedAt.Format(time.RFC3339),
        }
}</span>

func (h *orderHandler) GetAllHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        userID, err := utils.GetUserID(r.Context())
        if err != nil </span><span class="cov8" title="1">{
                w.WriteHeader(http.StatusUnauthorized)
                return
        }</span>

        <span class="cov8" title="1">orders, err := h.service.GetAll(r.Context(), userID)
        if err != nil </span><span class="cov8" title="1">{
                w.WriteHeader(http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">if orders == nil </span><span class="cov8" title="1">{
                w.WriteHeader(http.StatusNoContent)
                return
        }</span>

        <span class="cov8" title="1">ordersDto := make([]orderDTO, 0, len(orders))
        for _, order := range orders </span><span class="cov8" title="1">{
                ordersDto = append(ordersDto, h.mapOrderToDTO(order))
        }</span>

        <span class="cov8" title="1">render.JSON(w, r, ordersDto)</span>

}
</pre>
		
		<pre class="file" id="file7" style="display: none">package withdrawal

import (
        "context"
        "net/http"
        "time"

        "github.com/MxTrap/gophermart/internal/gophermart/controller/http/utils"
        "github.com/MxTrap/gophermart/internal/gophermart/entity"

        "github.com/go-chi/chi/v5"
        "github.com/go-chi/render"
)

type withdrawer interface {
        GetAll(ctx context.Context, userID int64) ([]entity.Withdrawal, error)
}

type withdrawalHandler struct {
        svc withdrawer
}

type authMiddleware interface {
        Validate(next http.Handler) http.Handler
}

func NewWithdrawalHandler(
        middleware authMiddleware,
        svc withdrawer,
) func(chi.Router) <span class="cov0" title="0">{
        h := &amp;withdrawalHandler{svc: svc}

        return func(r chi.Router) </span><span class="cov0" title="0">{
                r.Route("/withdrawals", func(r chi.Router) </span><span class="cov0" title="0">{
                        r.Use(middleware.Validate)
                        r.Get("/", h.GetAll)
                }</span>)

        }
}

type withdrawalDTO struct {
        Order       string  `json:"order"`
        Sum         float32 `json:"sum"`
        ProcessedAt string  `json:"processed_at"`
}

func (h *withdrawalHandler) GetAll(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        userID, err := utils.GetUserID(r.Context())
        if err != nil </span><span class="cov8" title="1">{
                w.WriteHeader(http.StatusUnauthorized)
                return
        }</span>

        <span class="cov8" title="1">withdrawals, err := h.svc.GetAll(r.Context(), userID)

        if err != nil </span><span class="cov8" title="1">{
                w.WriteHeader(http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">if withdrawals == nil </span><span class="cov8" title="1">{
                w.WriteHeader(http.StatusNoContent)
                return
        }</span>

        <span class="cov8" title="1">var withdrawalsDto []withdrawalDTO
        for _, withdrawal := range withdrawals </span><span class="cov8" title="1">{
                withdrawalsDto = append(
                        withdrawalsDto,
                        withdrawalDTO{
                                Order:       withdrawal.Order,
                                Sum:         withdrawal.Sum,
                                ProcessedAt: withdrawal.ProcessedAt.Format(time.RFC3339),
                        },
                )
        }</span>

        <span class="cov8" title="1">render.JSON(w, r, withdrawalsDto)</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package middlewares

import (
        "context"
        "net/http"

        "github.com/MxTrap/gophermart/internal/gophermart/common"
        "github.com/MxTrap/gophermart/internal/gophermart/entity"
)

type tokenValidator interface {
        Parse(token entity.Token) (int64, error)
}

type AuhtorizationMiddleware struct {
        validator tokenValidator
}

func NewAuhtorizationMiddleware(val tokenValidator) *AuhtorizationMiddleware <span class="cov8" title="1">{
        return &amp;AuhtorizationMiddleware{
                validator: val,
        }
}</span>

type UserIDKey string

func (m *AuhtorizationMiddleware) Validate(next http.Handler) http.Handler <span class="cov8" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                authHeader := r.Header.Get("Authorization")
                if authHeader == "" </span><span class="cov8" title="1">{
                        http.Error(w, common.ErrInvalidCredentials.Error(), http.StatusUnauthorized)
                        return
                }</span>

                <span class="cov8" title="1">userID, err := m.validator.Parse(entity.Token(authHeader))
                if err != nil </span><span class="cov8" title="1">{
                        http.Error(w, err.Error(), http.StatusUnauthorized)
                        return
                }</span>
                <span class="cov8" title="1">ctx := context.WithValue(r.Context(), UserIDKey("UserID"), userID)
                r = r.WithContext(ctx)

                next.ServeHTTP(w, r)</span>

        })
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package middlewares

import (
        "bytes"
        "net/http"

        "go.uber.org/zap"
)

type logger interface {
        With(args ...any) *zap.SugaredLogger
        Info(data ...any)
        Error(args ...any)
}

type responseWriter struct {
        http.ResponseWriter
        Code int
        Body *bytes.Buffer
}

func (w *responseWriter) WriteHeader(statusCode int) <span class="cov0" title="0">{
        w.Code = statusCode
}</span>

func (w *responseWriter) Write(data []byte) (int, error) <span class="cov0" title="0">{
        return w.Body.Write(data)
}</span>

func (w *responseWriter) Flush() <span class="cov0" title="0">{
        if w.Code != 0 </span><span class="cov0" title="0">{
                w.ResponseWriter.WriteHeader(w.Code)
        }</span>
        <span class="cov0" title="0">if w.Body.Len() &gt; 0 </span><span class="cov0" title="0">{
                w.ResponseWriter.Write(w.Body.Bytes())
        }</span>
}

func LoggerMiddleware(log logger) func(h http.Handler) http.Handler <span class="cov0" title="0">{
        return func(h http.Handler) http.Handler </span><span class="cov0" title="0">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                        log := log.With(r.RequestURI, r.Method)
                        rw := &amp;responseWriter{ResponseWriter: w, Body: new(bytes.Buffer)}
                        h.ServeHTTP(rw, r)
                        if rw.Code &gt;= 400 &amp;&amp; rw.Body.Len() &gt; 0 </span><span class="cov0" title="0">{
                                log.Error(rw.Body.String())
                                rw.Body.Reset()
                        }</span>
                        <span class="cov0" title="0">rw.Flush()</span>
                })
        }
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package utils

import (
        "context"
        "errors"

        "github.com/MxTrap/gophermart/internal/gophermart/controller/http/middlewares"
)

func GetUserID(ctx context.Context) (int64, error) <span class="cov8" title="1">{
        userID, ok := ctx.Value(middlewares.UserIDKey("UserID")).(int64)
        if !ok </span><span class="cov8" title="1">{
                return 0, errors.New("unknown user id")
        }</span>
        <span class="cov8" title="1">return userID, nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package migrator

import (
        "database/sql"
        "errors"
        "fmt"

        "github.com/MxTrap/gophermart/internal/utils"

        "github.com/golang-migrate/migrate/v4"
        "github.com/golang-migrate/migrate/v4/database/pgx"
        _ "github.com/golang-migrate/migrate/v4/source/file"
        "github.com/jackc/pgx/v5/pgxpool"
        "github.com/jackc/pgx/v5/stdlib"
)

type Migrator struct {
        migrator *migrate.Migrate
        db       *sql.DB
}

func NewMigrator(pool *pgxpool.Pool) (*Migrator, error) <span class="cov0" title="0">{
        db := stdlib.OpenDBFromPool(pool)

        driver, err := pgx.WithInstance(db, &amp;pgx.Config{})
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">m, err := migrate.NewWithDatabaseInstance(
                fmt.Sprintf("file://%s", utils.GetProjectPath()+"/migrations"),
                "postgres", driver)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;Migrator{
                migrator: m,
                db:       db,
        }, nil</span>
}

func (m *Migrator) InitializeDB() error <span class="cov0" title="0">{
        defer m.db.Close()
        defer m.migrator.Close()

        if err := m.migrator.Up(); err != nil &amp;&amp; !errors.Is(err, migrate.ErrNoChange) </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: internal/gophermart/repository/tmp.go

// Package mocks is a generated GoMock package.
package mocks

import (
        context "context"
        reflect "reflect"

        entity "github.com/MxTrap/gophermart/internal/gophermart/entity"
        gomock "github.com/golang/mock/gomock"
)

// MockBalanceOrderRepository is a mock of BalanceOrderRepository interface.
type MockBalanceOrderRepository struct {
        ctrl     *gomock.Controller
        recorder *MockBalanceOrderRepositoryMockRecorder
}

// MockBalanceOrderRepositoryMockRecorder is the mock recorder for MockBalanceOrderRepository.
type MockBalanceOrderRepositoryMockRecorder struct {
        mock *MockBalanceOrderRepository
}

// NewMockBalanceOrderRepository creates a new mock instance.
func NewMockBalanceOrderRepository(ctrl *gomock.Controller) *MockBalanceOrderRepository <span class="cov0" title="0">{
        mock := &amp;MockBalanceOrderRepository{ctrl: ctrl}
        mock.recorder = &amp;MockBalanceOrderRepositoryMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockBalanceOrderRepository) EXPECT() *MockBalanceOrderRepositoryMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// UpdateOrderBalance mocks base method.
func (m *MockBalanceOrderRepository) UpdateOrderBalance(ctx context.Context, order entity.Order) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UpdateOrderBalance", ctx, order)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// UpdateOrderBalance indicates an expected call of UpdateOrderBalance.
func (mr *MockBalanceOrderRepositoryMockRecorder) UpdateOrderBalance(ctx, order interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateOrderBalance", reflect.TypeOf((*MockBalanceOrderRepository)(nil).UpdateOrderBalance), ctx, order)
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: internal/gophermart/repository/tmp.go

// Package mocks is a generated GoMock package.
package mocks

import (
        context "context"
        reflect "reflect"

        entity "github.com/MxTrap/gophermart/internal/gophermart/entity"
        gomock "github.com/golang/mock/gomock"
        pgx "github.com/jackc/pgx/v5"
)

// MockBalanceRepository is a mock of BalanceRepository interface.
type MockBalanceRepository struct {
        ctrl     *gomock.Controller
        recorder *MockBalanceRepositoryMockRecorder
}

// MockBalanceRepositoryMockRecorder is the mock recorder for MockBalanceRepository.
type MockBalanceRepositoryMockRecorder struct {
        mock *MockBalanceRepository
}

// NewMockBalanceRepository creates a new mock instance.
func NewMockBalanceRepository(ctrl *gomock.Controller) *MockBalanceRepository <span class="cov8" title="1">{
        mock := &amp;MockBalanceRepository{ctrl: ctrl}
        mock.recorder = &amp;MockBalanceRepositoryMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockBalanceRepository) EXPECT() *MockBalanceRepositoryMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// Get mocks base method.
func (m *MockBalanceRepository) Get(ctx context.Context, userID int64) (entity.Balance, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Get", ctx, userID)
        ret0, _ := ret[0].(entity.Balance)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Get indicates an expected call of Get.
func (mr *MockBalanceRepositoryMockRecorder) Get(ctx, userID interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Get", reflect.TypeOf((*MockBalanceRepository)(nil).Get), ctx, userID)
}</span>

// Increase mocks base method.
func (m *MockBalanceRepository) Increase(ctx context.Context, tx pgx.Tx, userID int64, sum float32) error <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Increase", ctx, tx, userID, sum)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Increase indicates an expected call of Increase.
func (mr *MockBalanceRepositoryMockRecorder) Increase(ctx, tx, userID, sum interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Increase", reflect.TypeOf((*MockBalanceRepository)(nil).Increase), ctx, tx, userID, sum)
}</span>

// Withdraw mocks base method.
func (m *MockBalanceRepository) Withdraw(ctx context.Context, tx pgx.Tx, userID int64, sum float32) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Withdraw", ctx, tx, userID, sum)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Withdraw indicates an expected call of Withdraw.
func (mr *MockBalanceRepositoryMockRecorder) Withdraw(ctx, tx, userID, sum interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Withdraw", reflect.TypeOf((*MockBalanceRepository)(nil).Withdraw), ctx, tx, userID, sum)
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: internal/gophermart/repository/tmp.go

// Package mocks is a generated GoMock package.
package mocks

import (
        context "context"
        reflect "reflect"

        entity "github.com/MxTrap/gophermart/internal/gophermart/entity"
        gomock "github.com/golang/mock/gomock"
)

// MockBalanceWithdrawalRepository is a mock of BalanceWithdrawalRepository interface.
type MockBalanceWithdrawalRepository struct {
        ctrl     *gomock.Controller
        recorder *MockBalanceWithdrawalRepositoryMockRecorder
}

// MockBalanceWithdrawalRepositoryMockRecorder is the mock recorder for MockBalanceWithdrawalRepository.
type MockBalanceWithdrawalRepositoryMockRecorder struct {
        mock *MockBalanceWithdrawalRepository
}

// NewMockBalanceWithdrawalRepository creates a new mock instance.
func NewMockBalanceWithdrawalRepository(ctrl *gomock.Controller) *MockBalanceWithdrawalRepository <span class="cov8" title="1">{
        mock := &amp;MockBalanceWithdrawalRepository{ctrl: ctrl}
        mock.recorder = &amp;MockBalanceWithdrawalRepositoryMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockBalanceWithdrawalRepository) EXPECT() *MockBalanceWithdrawalRepositoryMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// Withdraw mocks base method.
func (m *MockBalanceWithdrawalRepository) Withdraw(ctx context.Context, userID int64, withdrawal entity.Withdrawal) error <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Withdraw", ctx, userID, withdrawal)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Withdraw indicates an expected call of Withdraw.
func (mr *MockBalanceWithdrawalRepositoryMockRecorder) Withdraw(ctx, userID, withdrawal interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Withdraw", reflect.TypeOf((*MockBalanceWithdrawalRepository)(nil).Withdraw), ctx, userID, withdrawal)
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: internal/gophermart/repository/tmp.go

// Package mocks is a generated GoMock package.
package mocks

import (
        context "context"
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
        pgx "github.com/jackc/pgx/v5"
)

// MockDBPool is a mock of DBPool interface.
type MockDBPool struct {
        ctrl     *gomock.Controller
        recorder *MockDBPoolMockRecorder
}

// MockDBPoolMockRecorder is the mock recorder for MockDBPool.
type MockDBPoolMockRecorder struct {
        mock *MockDBPool
}

// NewMockDBPool creates a new mock instance.
func NewMockDBPool(ctrl *gomock.Controller) *MockDBPool <span class="cov8" title="1">{
        mock := &amp;MockDBPool{ctrl: ctrl}
        mock.recorder = &amp;MockDBPoolMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockDBPool) EXPECT() *MockDBPoolMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// BeginTx mocks base method.
func (m *MockDBPool) BeginTx(ctx context.Context, txOptions pgx.TxOptions) (pgx.Tx, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "BeginTx", ctx, txOptions)
        ret0, _ := ret[0].(pgx.Tx)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// BeginTx indicates an expected call of BeginTx.
func (mr *MockDBPoolMockRecorder) BeginTx(ctx, txOptions interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BeginTx", reflect.TypeOf((*MockDBPool)(nil).BeginTx), ctx, txOptions)
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: internal/gophermart/repository/tmp.go

// Package mocks is a generated GoMock package.
package mocks

import (
        context "context"
        reflect "reflect"

        entity "github.com/MxTrap/gophermart/internal/gophermart/entity"
        gomock "github.com/golang/mock/gomock"
        pgx "github.com/jackc/pgx/v5"
)

// MockOrderRepository is a mock of OrderRepository interface.
type MockOrderRepository struct {
        ctrl     *gomock.Controller
        recorder *MockOrderRepositoryMockRecorder
}

// MockOrderRepositoryMockRecorder is the mock recorder for MockOrderRepository.
type MockOrderRepositoryMockRecorder struct {
        mock *MockOrderRepository
}

// NewMockOrderRepository creates a new mock instance.
func NewMockOrderRepository(ctrl *gomock.Controller) *MockOrderRepository <span class="cov8" title="1">{
        mock := &amp;MockOrderRepository{ctrl: ctrl}
        mock.recorder = &amp;MockOrderRepositoryMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockOrderRepository) EXPECT() *MockOrderRepositoryMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// Find mocks base method.
func (m *MockOrderRepository) Find(ctx context.Context, number string) (entity.Order, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Find", ctx, number)
        ret0, _ := ret[0].(entity.Order)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Find indicates an expected call of Find.
func (mr *MockOrderRepositoryMockRecorder) Find(ctx, number interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Find", reflect.TypeOf((*MockOrderRepository)(nil).Find), ctx, number)
}</span>

// GetAll mocks base method.
func (m *MockOrderRepository) GetAll(ctx context.Context, userID int64) ([]entity.Order, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetAll", ctx, userID)
        ret0, _ := ret[0].([]entity.Order)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetAll indicates an expected call of GetAll.
func (mr *MockOrderRepositoryMockRecorder) GetAll(ctx, userID interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAll", reflect.TypeOf((*MockOrderRepository)(nil).GetAll), ctx, userID)
}</span>

// Save mocks base method.
func (m *MockOrderRepository) Save(ctx context.Context, order entity.Order) error <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Save", ctx, order)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Save indicates an expected call of Save.
func (mr *MockOrderRepositoryMockRecorder) Save(ctx, order interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Save", reflect.TypeOf((*MockOrderRepository)(nil).Save), ctx, order)
}</span>

// Update mocks base method.
func (m *MockOrderRepository) Update(ctx context.Context, tx pgx.Tx, order entity.Order) error <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Update", ctx, tx, order)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Update indicates an expected call of Update.
func (mr *MockOrderRepositoryMockRecorder) Update(ctx, tx, order interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Update", reflect.TypeOf((*MockOrderRepository)(nil).Update), ctx, tx, order)
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package mocks

import (
        "errors"
        "github.com/MxTrap/gophermart/internal/gophermart/entity"
        "github.com/jackc/pgx/v5"
        "github.com/jackc/pgx/v5/pgconn"
)

type MockRows struct {
        data  []entity.Balance
        index int
}

func (r *MockRows) Close() <span class="cov0" title="0">{
        r.index = -1
}</span>

func (r *MockRows) Next() bool <span class="cov0" title="0">{
        if r.index+1 &lt; len(r.data) </span><span class="cov0" title="0">{
                r.index++
                return true
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (r *MockRows) Scan(dest ...interface{}) error <span class="cov0" title="0">{
        if r.index &lt; 0 || r.index &gt;= len(r.data) </span><span class="cov0" title="0">{
                return errors.New("no rows")
        }</span>
        <span class="cov0" title="0">b := r.data[r.index]
        if len(dest) == 2 </span><span class="cov0" title="0">{
                dest[0] = &amp;b.Balance
                dest[1] = &amp;b.Withdrawn
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *MockRows) Values() ([]interface{}, error) <span class="cov0" title="0">{
        if r.index &lt; 0 || r.index &gt;= len(r.data) </span><span class="cov0" title="0">{
                return nil, errors.New("no rows")
        }</span>
        <span class="cov0" title="0">b := r.data[r.index]
        return []interface{}{b.Balance, b.Withdrawn}, nil</span>
}

func (r *MockRows) FieldDescriptions() []pgconn.FieldDescription <span class="cov0" title="0">{
        return nil
}</span>

func (r *MockRows) RawValues() [][]byte <span class="cov0" title="0">{
        return nil
}</span>

func (r *MockRows) Conn() *pgx.Conn <span class="cov0" title="0">{
        return nil
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: internal/gophermart/repository/tmp.go

// Package mocks is a generated GoMock package.
package mocks

import (
        reflect "reflect"

        entity "github.com/MxTrap/gophermart/internal/gophermart/entity"
        gomock "github.com/golang/mock/gomock"
)

// MockStorageService is a mock of StorageService interface.
type MockStorageService struct {
        ctrl     *gomock.Controller
        recorder *MockStorageServiceMockRecorder
}

// MockStorageServiceMockRecorder is the mock recorder for MockStorageService.
type MockStorageServiceMockRecorder struct {
        mock *MockStorageService
}

// NewMockStorageService creates a new mock instance.
func NewMockStorageService(ctrl *gomock.Controller) *MockStorageService <span class="cov8" title="1">{
        mock := &amp;MockStorageService{ctrl: ctrl}
        mock.recorder = &amp;MockStorageServiceMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockStorageService) EXPECT() *MockStorageServiceMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// Get mocks base method.
func (m *MockStorageService) Get(elemCount int) []entity.Order <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Get", elemCount)
        ret0, _ := ret[0].([]entity.Order)
        return ret0
}</span>

// Get indicates an expected call of Get.
func (mr *MockStorageServiceMockRecorder) Get(elemCount interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Get", reflect.TypeOf((*MockStorageService)(nil).Get), elemCount)
}</span>

// Push mocks base method.
func (m *MockStorageService) Push(el entity.Order) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        m.ctrl.Call(m, "Push", el)
}</span>

// Push indicates an expected call of Push.
func (mr *MockStorageServiceMockRecorder) Push(el interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Push", reflect.TypeOf((*MockStorageService)(nil).Push), el)
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package mocks

import (
        "context"
        "github.com/jackc/pgx/v5"
        "github.com/jackc/pgx/v5/pgconn"
)

type MockTx struct {
        CommitFn   func(ctx context.Context) error
        RollbackFn func(ctx context.Context) error
        ExecFn     func(ctx context.Context, sql string, arguments ...interface{}) (pgconn.CommandTag, error)
}

func (m *MockTx) LargeObjects() pgx.LargeObjects <span class="cov0" title="0">{
        return pgx.LargeObjects{}
}</span>

func (m *MockTx) Prepare(ctx context.Context, name, sql string) (*pgconn.StatementDescription, error) <span class="cov0" title="0">{
        return nil, nil
}</span>

func (m *MockTx) Commit(ctx context.Context) error <span class="cov8" title="1">{
        if m.CommitFn != nil </span><span class="cov8" title="1">{
                return m.CommitFn(ctx)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *MockTx) Rollback(ctx context.Context) error <span class="cov8" title="1">{
        if m.RollbackFn != nil </span><span class="cov8" title="1">{
                return m.RollbackFn(ctx)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Реализуем остальные методы pgx.Tx как заглушки, если они не нужны
func (m *MockTx) Begin(ctx context.Context) (pgx.Tx, error) <span class="cov0" title="0">{
        return nil, nil
}</span>
func (m *MockTx) Exec(ctx context.Context, sql string, arguments ...interface{}) (pgconn.CommandTag, error) <span class="cov0" title="0">{
        return pgconn.CommandTag{}, nil
}</span>
func (m *MockTx) Query(ctx context.Context, sql string, args ...interface{}) (pgx.Rows, error) <span class="cov0" title="0">{
        return nil, nil
}</span>
func (m *MockTx) QueryRow(ctx context.Context, sql string, args ...interface{}) pgx.Row <span class="cov0" title="0">{
        return nil
}</span>
func (m *MockTx) SendBatch(ctx context.Context, b *pgx.Batch) pgx.BatchResults <span class="cov0" title="0">{
        return nil
}</span>
func (m *MockTx) CopyFrom(ctx context.Context, tableName pgx.Identifier, columnNames []string, rowSrc pgx.CopyFromSource) (int64, error) <span class="cov0" title="0">{
        return 0, nil
}</span>
func (m *MockTx) Conn() *pgx.Conn <span class="cov0" title="0">{
        return nil
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: internal/gophermart/repository/tmp.go

// Package mocks is a generated GoMock package.
package mocks

import (
        context "context"
        reflect "reflect"

        entity "github.com/MxTrap/gophermart/internal/gophermart/entity"
        gomock "github.com/golang/mock/gomock"
)

// MockUserRepository is a mock of UserRepository interface.
type MockUserRepository struct {
        ctrl     *gomock.Controller
        recorder *MockUserRepositoryMockRecorder
}

// MockUserRepositoryMockRecorder is the mock recorder for MockUserRepository.
type MockUserRepositoryMockRecorder struct {
        mock *MockUserRepository
}

// NewMockUserRepository creates a new mock instance.
func NewMockUserRepository(ctrl *gomock.Controller) *MockUserRepository <span class="cov0" title="0">{
        mock := &amp;MockUserRepository{ctrl: ctrl}
        mock.recorder = &amp;MockUserRepositoryMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockUserRepository) EXPECT() *MockUserRepositoryMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// FindUserByID mocks base method.
func (m *MockUserRepository) FindUserByID(ctx context.Context, userID int64) (entity.User, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "FindUserByID", ctx, userID)
        ret0, _ := ret[0].(entity.User)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// FindUserByID indicates an expected call of FindUserByID.
func (mr *MockUserRepositoryMockRecorder) FindUserByID(ctx, userID interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindUserByID", reflect.TypeOf((*MockUserRepository)(nil).FindUserByID), ctx, userID)
}</span>

// FindUserByUsername mocks base method.
func (m *MockUserRepository) FindUserByUsername(ctx context.Context, username string) (entity.User, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "FindUserByUsername", ctx, username)
        ret0, _ := ret[0].(entity.User)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// FindUserByUsername indicates an expected call of FindUserByUsername.
func (mr *MockUserRepositoryMockRecorder) FindUserByUsername(ctx, username interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindUserByUsername", reflect.TypeOf((*MockUserRepository)(nil).FindUserByUsername), ctx, username)
}</span>

// SaveUser mocks base method.
func (m *MockUserRepository) SaveUser(ctx context.Context, user entity.User) (int64, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "SaveUser", ctx, user)
        ret0, _ := ret[0].(int64)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// SaveUser indicates an expected call of SaveUser.
func (mr *MockUserRepositoryMockRecorder) SaveUser(ctx, user interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SaveUser", reflect.TypeOf((*MockUserRepository)(nil).SaveUser), ctx, user)
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: internal/gophermart/repository/tmp.go

// Package mocks is a generated GoMock package.
package mocks

import (
        context "context"
        reflect "reflect"

        entity "github.com/MxTrap/gophermart/internal/gophermart/entity"
        gomock "github.com/golang/mock/gomock"
        pgx "github.com/jackc/pgx/v5"
)

// MockWithdrawalRepository is a mock of WithdrawalRepository interface.
type MockWithdrawalRepository struct {
        ctrl     *gomock.Controller
        recorder *MockWithdrawalRepositoryMockRecorder
}

// MockWithdrawalRepositoryMockRecorder is the mock recorder for MockWithdrawalRepository.
type MockWithdrawalRepositoryMockRecorder struct {
        mock *MockWithdrawalRepository
}

// NewMockWithdrawalRepository creates a new mock instance.
func NewMockWithdrawalRepository(ctrl *gomock.Controller) *MockWithdrawalRepository <span class="cov8" title="1">{
        mock := &amp;MockWithdrawalRepository{ctrl: ctrl}
        mock.recorder = &amp;MockWithdrawalRepositoryMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockWithdrawalRepository) EXPECT() *MockWithdrawalRepositoryMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// GetAll mocks base method.
func (m *MockWithdrawalRepository) GetAll(ctx context.Context, userID int64) ([]entity.Withdrawal, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetAll", ctx, userID)
        ret0, _ := ret[0].([]entity.Withdrawal)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetAll indicates an expected call of GetAll.
func (mr *MockWithdrawalRepositoryMockRecorder) GetAll(ctx, userID interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAll", reflect.TypeOf((*MockWithdrawalRepository)(nil).GetAll), ctx, userID)
}</span>

// Save mocks base method.
func (m *MockWithdrawalRepository) Save(ctx context.Context, tx *pgx.Tx, userID int64, withdrawn entity.Withdrawal) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Save", ctx, tx, userID, withdrawn)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Save indicates an expected call of Save.
func (mr *MockWithdrawalRepositoryMockRecorder) Save(ctx, tx, userID, withdrawn interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Save", reflect.TypeOf((*MockWithdrawalRepository)(nil).Save), ctx, tx, userID, withdrawn)
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">package balance

import (
        "context"
        storage "github.com/MxTrap/gophermart/internal/gophermart/repository"

        "github.com/MxTrap/gophermart/internal/gophermart/entity"
        "github.com/jackc/pgx/v5"
)

type db interface {
        Query(ctx context.Context, sql string, args ...any) (pgx.Rows, error)
}

type BalanceRepository struct {
        db db
}

const repoName = "postgres.BalanceRepo."

func NewBalanceRepository(pool db) *BalanceRepository <span class="cov0" title="0">{
        return &amp;BalanceRepository{
                db: pool,
        }
}</span>

func (*BalanceRepository) Increase(ctx context.Context, tx pgx.Tx, userID int64, sum float32) error <span class="cov0" title="0">{
        _, err := tx.Exec(ctx, increaseBalanceStmt, sum, userID)
        if err != nil </span><span class="cov0" title="0">{
                return storage.NewRepositoryError(repoName+"Increase", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (*BalanceRepository) Withdraw(ctx context.Context, tx pgx.Tx, userID int64, sum float32) error <span class="cov0" title="0">{
        _, err := tx.Exec(ctx, withdrawalStmt, sum, userID)
        if err != nil </span><span class="cov0" title="0">{
                return storage.NewRepositoryError(repoName+"Withdraw", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *BalanceRepository) Get(ctx context.Context, userID int64) (entity.Balance, error) <span class="cov0" title="0">{
        const op = repoName + "Get"
        var balance entity.Balance
        row, err := r.db.Query(ctx, selectStmt, userID)
        if err != nil </span><span class="cov0" title="0">{
                return balance, storage.NewRepositoryError(op, err)
        }</span>
        <span class="cov0" title="0">defer row.Close()

        balance, err = pgx.CollectOneRow(row, pgx.RowToStructByName[entity.Balance])
        if err != nil </span><span class="cov0" title="0">{
                return balance, storage.NewRepositoryError(op, err)
        }</span>

        <span class="cov0" title="0">return balance, nil</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package combined

import (
        "context"
        "errors"
        "github.com/MxTrap/gophermart/internal/gophermart/entity"
        "github.com/jackc/pgx/v5"
)

type orderRepo interface {
        Update(ctx context.Context, tx pgx.Tx, order entity.Order) error
}

type balanceRepo interface {
        Increase(ctx context.Context, tx pgx.Tx, userID int64, accrual float32) error
}

type db interface {
        BeginTx(ctx context.Context, txOptions pgx.TxOptions) (pgx.Tx, error)
}

type OrderBalanceRepo struct {
        db
        orderRepo
        balanceRepo
}

func NewOrderBalanceRepo(pool db, order orderRepo, balance balanceRepo) *OrderBalanceRepo <span class="cov8" title="1">{
        return &amp;OrderBalanceRepo{
                db:          pool,
                orderRepo:   order,
                balanceRepo: balance,
        }
}</span>

func (r *OrderBalanceRepo) UpdateOrderBalance(ctx context.Context, order entity.Order) error <span class="cov8" title="1">{
        tx, err := r.db.BeginTx(ctx, pgx.TxOptions{})
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">err = r.orderRepo.Update(ctx, tx, order)
        if err != nil </span><span class="cov8" title="1">{
                rErr := tx.Rollback(ctx)
                if rErr != nil </span><span class="cov8" title="1">{
                        err = errors.Join(rErr, err)
                }</span>
                <span class="cov8" title="1">return err</span>
        }

        <span class="cov8" title="1">if order.Accrual != nil </span><span class="cov8" title="1">{
                err = r.balanceRepo.Increase(ctx, tx, order.UserID, *order.Accrual)
                if err != nil </span><span class="cov8" title="1">{
                        rErr := tx.Rollback(ctx)
                        if rErr != nil </span><span class="cov0" title="0">{
                                err = errors.Join(rErr, err)
                        }</span>
                        <span class="cov8" title="1">return err</span>
                }
        }

        <span class="cov8" title="1">if err := tx.Commit(ctx); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package combined

import (
        "context"
        "errors"

        "github.com/MxTrap/gophermart/internal/gophermart/common"
        "github.com/MxTrap/gophermart/internal/gophermart/entity"
        "github.com/jackc/pgx/v5"
        "github.com/jackc/pgx/v5/pgconn"
        "github.com/jackc/pgx/v5/pgxpool"
)

type withdrawn interface {
        Save(ctx context.Context, tx pgx.Tx, userID int64, withdrawn entity.Withdrawal) error
}

type balance interface {
        Withdraw(ctx context.Context, tx pgx.Tx, userID int64, sum float32) error
}

type BalanceWithdrawnRepo struct {
        db             *pgxpool.Pool
        balanceRepo    balance
        withdrawalRepo withdrawn
}

func NewBalanceWithdrawnRepo(db *pgxpool.Pool, bRepo balance, wRepo withdrawn) *BalanceWithdrawnRepo <span class="cov0" title="0">{
        return &amp;BalanceWithdrawnRepo{
                db:             db,
                balanceRepo:    bRepo,
                withdrawalRepo: wRepo,
        }
}</span>

func (r *BalanceWithdrawnRepo) Withdraw(ctx context.Context, userID int64, withdrawal entity.Withdrawal) error <span class="cov0" title="0">{
        tx, err := r.db.Begin(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = r.balanceRepo.Withdraw(ctx, tx, userID, withdrawal.Sum)

        if err != nil </span><span class="cov0" title="0">{
                err := tx.Rollback(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">var pgErr *pgconn.PgError
                if errors.As(err, &amp;pgErr) &amp;&amp; pgErr.Code == "23514" </span><span class="cov0" title="0">{
                        return common.ErrInsufficientBalance
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov0" title="0">err = r.withdrawalRepo.Save(ctx, tx, userID, withdrawal)
        if err != nil </span><span class="cov0" title="0">{
                err := tx.Rollback(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov0" title="0">return tx.Commit(ctx)</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package order

import (
        "context"
        "errors"
        storage "github.com/MxTrap/gophermart/internal/gophermart/repository"

        "github.com/MxTrap/gophermart/internal/gophermart/entity"
        "github.com/jackc/pgx/v5"
        "github.com/jackc/pgx/v5/pgxpool"
)

type OrderRepository struct {
        db *pgxpool.Pool
}

const repoName = "postgres.OrderRepo."

func NewOrderRepository(pool *pgxpool.Pool) *OrderRepository <span class="cov0" title="0">{
        return &amp;OrderRepository{
                db: pool,
        }
}</span>

func (r *OrderRepository) Save(ctx context.Context, order entity.Order) error <span class="cov0" title="0">{
        _, err := r.db.Exec(
                ctx,
                insertStmt,
                order.UserID,
                order.Number,
                order.Status,
                order.Accrual,
                order.UploadedAt,
        )
        if err != nil </span><span class="cov0" title="0">{
                return storage.NewRepositoryError(repoName+"Save", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r *OrderRepository) Find(ctx context.Context, number string) (entity.Order, error) <span class="cov0" title="0">{
        const op = repoName + "Find"
        var order entity.Order
        row, err := r.db.Query(ctx, selectByNumber, number)
        if err != nil </span><span class="cov0" title="0">{
                return order, storage.NewRepositoryError(op, err)
        }</span>
        <span class="cov0" title="0">defer row.Close()
        order, err = pgx.CollectOneRow(row, pgx.RowToStructByName[entity.Order])
        if err == nil || errors.Is(err, pgx.ErrNoRows) </span><span class="cov0" title="0">{
                return order, nil
        }</span>

        <span class="cov0" title="0">return order, storage.NewRepositoryError(op, err)</span>
}

func (r *OrderRepository) Update(ctx context.Context, tx pgx.Tx, order entity.Order) error <span class="cov0" title="0">{
        _, err := tx.Exec(ctx, updateStmt, order.Status, order.Accrual, order.Number)
        if err != nil </span><span class="cov0" title="0">{
                return storage.NewRepositoryError(repoName+"Update", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *OrderRepository) GetAll(ctx context.Context, userID int64) ([]entity.Order, error) <span class="cov0" title="0">{
        const op = repoName + "GetAll"
        var orders []entity.Order
        rows, err := r.db.Query(ctx, selectAllStmt, userID)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, pgx.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return orders, storage.NewRepositoryError(op, err)</span>
        }
        <span class="cov0" title="0">defer rows.Close()

        orders, err = pgx.CollectRows(rows, pgx.RowToStructByName[entity.Order])
        if err != nil </span><span class="cov0" title="0">{
                return orders, storage.NewRepositoryError(op, err)
        }</span>
        <span class="cov0" title="0">return orders, nil</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package postgres

import (
        "context"

        "github.com/jackc/pgx/v5/pgxpool"
)

type Storage struct {
        Pool *pgxpool.Pool
}

func NewPostgresStorage(ctx context.Context, conString string) (*Storage, error) <span class="cov0" title="0">{
        pool, err := pgxpool.New(ctx, conString)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;Storage{
                Pool: pool,
        }, nil</span>
}

func (s Storage) Stop() <span class="cov0" title="0">{
        s.Pool.Close()
}</span>
</pre>
		
		<pre class="file" id="file27" style="display: none">package posgress

import (
        "context"
        "errors"

        "github.com/MxTrap/gophermart/internal/gophermart/common"
        "github.com/MxTrap/gophermart/internal/gophermart/entity"
        storage "github.com/MxTrap/gophermart/internal/gophermart/repository"

        "github.com/jackc/pgx/v5"
        "github.com/jackc/pgx/v5/pgxpool"
)

type UserRepository struct {
        db *pgxpool.Pool
}

func NewUserRepository(pool *pgxpool.Pool) *UserRepository <span class="cov0" title="0">{
        return &amp;UserRepository{
                db: pool,
        }
}</span>

const repoName = "postgres.UserRepo."

func (s UserRepository) SaveUser(
        ctx context.Context,
        user entity.User,
) (int64, error) <span class="cov0" title="0">{
        var id int64
        err := s.db.QueryRow(ctx, insertStmt, user.Login, user.Password).Scan(&amp;id)

        if err != nil </span><span class="cov0" title="0">{
                return 0, storage.NewRepositoryError(repoName+".SaveUser", err)
        }</span>

        <span class="cov0" title="0">return id, nil</span>
}

func (s UserRepository) collectUser(rows pgx.Rows) (entity.User, error) <span class="cov0" title="0">{
        const op = repoName + "collectUser"
        user, err := pgx.CollectOneRow(rows, pgx.RowToStructByPos[entity.User])
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, pgx.ErrNoRows) </span><span class="cov0" title="0">{
                        return user, storage.NewRepositoryError(op, common.ErrUserNotFound)
                }</span>
                <span class="cov0" title="0">return user, storage.NewRepositoryError(op, err)</span>
        }
        <span class="cov0" title="0">return user, nil</span>
}

func (s UserRepository) FindUserByID(ctx context.Context, userID int64) (entity.User, error) <span class="cov0" title="0">{
        var user entity.User

        row, err := s.db.Query(ctx, findByIDStmt, userID)
        if err != nil </span><span class="cov0" title="0">{
                return user, storage.NewRepositoryError(repoName+"FindUserByID", err)
        }</span>
        <span class="cov0" title="0">defer row.Close()

        return s.collectUser(row)</span>
}

func (s UserRepository) FindUserByUsername(ctx context.Context, username string) (entity.User, error) <span class="cov0" title="0">{
        var user entity.User

        row, err := s.db.Query(ctx, findByUsernameStmt, username)
        if err != nil </span><span class="cov0" title="0">{
                return user, storage.NewRepositoryError(repoName+"FindUserByUsername", err)
        }</span>
        <span class="cov0" title="0">defer row.Close()

        return s.collectUser(row)</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package withdrawn

import (
        "context"
        storage "github.com/MxTrap/gophermart/internal/gophermart/repository"

        "github.com/MxTrap/gophermart/internal/gophermart/entity"
        "github.com/jackc/pgx/v5"
        "github.com/jackc/pgx/v5/pgxpool"
)

type WithdrawnRepo struct {
        db *pgxpool.Pool
}

const repoName = "postgres.WithdrawalRepo."

func NewWithdrawnRepo(db *pgxpool.Pool) *WithdrawnRepo <span class="cov0" title="0">{
        return &amp;WithdrawnRepo{
                db: db,
        }
}</span>

func (r *WithdrawnRepo) GetAll(ctx context.Context, userID int64) ([]entity.Withdrawal, error) <span class="cov0" title="0">{
        const op = repoName + "GetAll"
        rows, err := r.db.Query(ctx, selectStmt, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, storage.NewRepositoryError(op, err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        withdrawals, err := pgx.CollectRows(rows, pgx.RowToStructByPos[entity.Withdrawal])
        if err != nil </span><span class="cov0" title="0">{
                return nil, storage.NewRepositoryError(op, err)
        }</span>

        <span class="cov0" title="0">return withdrawals, nil</span>
}

func (*WithdrawnRepo) Save(ctx context.Context, tx pgx.Tx, userID int64, withdrawn entity.Withdrawal) error <span class="cov0" title="0">{
        _, err := tx.Exec(ctx, insertStmt, userID, withdrawn.Order, withdrawn.Sum, withdrawn.ProcessedAt)
        if err != nil </span><span class="cov0" title="0">{
                return storage.NewRepositoryError(repoName+"Save", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package storage

import "fmt"

type RepositoryError struct {
        Operation string
        Err       error
}

func NewRepositoryError(operation string, err error) *RepositoryError <span class="cov8" title="1">{
        return &amp;RepositoryError{
                Operation: operation,
                Err:       err,
        }
}</span>

func (e *RepositoryError) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf("RepositoryError: operation: %s, error: %s", e.Operation, e.Err.Error())
}</span>

func (e *RepositoryError) Unwrap() error <span class="cov8" title="1">{
        return e.Err
}</span>
</pre>
		
		<pre class="file" id="file30" style="display: none">package accrual

import (
        "errors"
        "fmt"
        "net/http"

        "github.com/MxTrap/gophermart/internal/gophermart/common"
        "github.com/MxTrap/gophermart/internal/gophermart/entity"
        "github.com/MxTrap/gophermart/logger"
        "resty.dev/v3"
)

type AccrualService struct {
        log *logger.Logger
        url string
}

func NewAccrualService(log *logger.Logger, url string) *AccrualService <span class="cov8" title="1">{
        return &amp;AccrualService{
                log: log,
                url: url,
        }
}</span>

type accrualDto struct {
        Order   string   `json:"order"`
        Status  string   `json:"status"`
        Accrual *float32 `json:"accrual,omitempty"`
}

func (s *AccrualService) GetOrderAccrual(number string) (entity.Order, error) <span class="cov8" title="1">{
        var order accrualDto
        res, err := resty.New().
                R().
                SetResult(&amp;order).
                Get(fmt.Sprintf("%s/api/orders/%s", s.url, number))

        if err != nil </span><span class="cov8" title="1">{
                return entity.Order{}, err
        }</span>

        <span class="cov8" title="1">if res.StatusCode() == http.StatusNoContent </span><span class="cov8" title="1">{
                return entity.Order{}, common.ErrNonExistentOrder
        }</span>

        <span class="cov8" title="1">if res.StatusCode() != http.StatusOK </span><span class="cov8" title="1">{
                return entity.Order{}, errors.New(res.Status())
        }</span>

        <span class="cov8" title="1">return s.mapDtoToOrder(order), nil</span>
}

func (*AccrualService) mapDtoToOrder(dto accrualDto) entity.Order <span class="cov8" title="1">{
        status := dto.Status
        if status == "REGISTERED" </span><span class="cov8" title="1">{
                status = entity.OrderNew
        }</span>
        <span class="cov8" title="1">return entity.Order{
                Status:  status,
                Accrual: dto.Accrual,
        }</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package auth

import (
        "context"
        "errors"
        "time"

        "github.com/MxTrap/gophermart/internal/gophermart/common"
        "github.com/MxTrap/gophermart/internal/gophermart/entity"
        "github.com/MxTrap/gophermart/logger"

        "golang.org/x/crypto/bcrypt"
)

type userFinder interface {
        FindUserByUsername(ctx context.Context, username string) (entity.User, error)
        FindUserByID(ctx context.Context, userID int64) (entity.User, error)
}

type userSaver interface {
        SaveUser(ctx context.Context, user entity.User) (uid int64, err error)
}

type userRepo interface {
        userSaver
        userFinder
}

type jwtService interface {
        GenerateAccessToken(user entity.User, ttl time.Duration) (entity.Token, error)
}

type AuthService struct {
        log      *logger.Logger
        userRepo userRepo
        jwtSvc   jwtService
        tokenTTL time.Duration
}

func NewAuthService(
        logger *logger.Logger,
        userRepo userRepo,
        jwtSvc jwtService,
        tokenTTL time.Duration,
) *AuthService <span class="cov8" title="1">{
        return &amp;AuthService{
                log:      logger,
                userRepo: userRepo,
                jwtSvc:   jwtSvc,
                tokenTTL: tokenTTL,
        }
}</span>

func (s *AuthService) RegisterNewUser(ctx context.Context, user entity.User) (entity.Token, error) <span class="cov8" title="1">{
        log := s.log.With("op", "AuthService.RegisterNewUser", "login", user.Login)
        var token entity.Token

        existingUser, err := s.userRepo.FindUserByUsername(ctx, user.Login)
        if err != nil &amp;&amp; !errors.Is(err, common.ErrUserNotFound) </span><span class="cov8" title="1">{
                log.Error("failed to find existing user", err)
                return token, common.ErrInternalError
        }</span>
        <span class="cov8" title="1">if existingUser != (entity.User{}) </span><span class="cov8" title="1">{
                return token, common.ErrUserAlreadyExist
        }</span>

        <span class="cov8" title="1">passHash, err := bcrypt.GenerateFromPassword([]byte(user.Password), bcrypt.DefaultCost)

        if err != nil </span><span class="cov0" title="0">{
                log.Error("failed to generate password hash: ", err)

                return token, common.ErrInternalError
        }</span>

        <span class="cov8" title="1">user.Password = string(passHash)
        id, err := s.userRepo.SaveUser(ctx, user)

        if err != nil </span><span class="cov8" title="1">{
                log.Error("failed to save user", err)
                return token, common.ErrInternalError
        }</span>
        <span class="cov8" title="1">user.ID = id
        token, err = s.jwtSvc.GenerateAccessToken(user, s.tokenTTL)
        if err != nil </span><span class="cov8" title="1">{
                log.Error("failed to generate tokens", err)
                return token, err
        }</span>

        <span class="cov8" title="1">return token, nil</span>
}

func (s *AuthService) Login(ctx context.Context, user entity.User) (entity.Token, error) <span class="cov8" title="1">{
        log := s.log.With("op", "AuthService.Login", "login", user.Login)

        var token entity.Token

        existingUser, err := s.userRepo.FindUserByUsername(ctx, user.Login)

        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, common.ErrUserNotFound) </span><span class="cov8" title="1">{
                        log.Info("user not found", err)
                        return token, common.ErrInvalidCredentials
                }</span>

                <span class="cov8" title="1">log.Error(err)
                return token, common.ErrInternalError</span>
        }

        <span class="cov8" title="1">if err := bcrypt.CompareHashAndPassword([]byte(existingUser.Password), []byte(user.Password)); err != nil </span><span class="cov8" title="1">{
                log.Info("invalid password", err)

                return token, common.ErrInvalidCredentials
        }</span>

        <span class="cov8" title="1">token, err = s.jwtSvc.GenerateAccessToken(existingUser, s.tokenTTL)
        if err != nil </span><span class="cov8" title="1">{
                log.Error("failed to generate tokens", err)
                return token, common.ErrInternalError
        }</span>

        <span class="cov8" title="1">return token, nil</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package balance

import (
        "context"

        "github.com/MxTrap/gophermart/internal/gophermart/entity"
        "github.com/MxTrap/gophermart/logger"
)

type balanceRepo interface {
        Get(ctx context.Context, userID int64) (entity.Balance, error)
}

type BalanceService struct {
        log  *logger.Logger
        repo balanceRepo
}

func NewBalanceService(log *logger.Logger, repo balanceRepo) *BalanceService <span class="cov8" title="1">{
        return &amp;BalanceService{
                log:  log,
                repo: repo,
        }
}</span>

func (s *BalanceService) Get(ctx context.Context, userID int64) (entity.Balance, error) <span class="cov8" title="1">{
        log := s.log.With("op", "BalanceService.Get")

        balance, err := s.repo.Get(ctx, userID)

        if err != nil </span><span class="cov8" title="1">{
                log.Error(err)
                return balance, err
        }</span>

        <span class="cov8" title="1">return balance, nil</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package jwt

import (
        "errors"
        "time"

        "github.com/MxTrap/gophermart/internal/gophermart/common"
        "github.com/MxTrap/gophermart/internal/gophermart/entity"

        "github.com/golang-jwt/jwt/v5"
)

type JwtService struct {
        secretKey string
}

func NewJWTService(secretKey string) *JwtService <span class="cov8" title="1">{
        return &amp;JwtService{
                secretKey: secretKey,
        }
}</span>

func (s JwtService) GenerateAccessToken(user entity.User, ttl time.Duration) (entity.Token, error) <span class="cov8" title="1">{
        token := jwt.New(jwt.SigningMethodHS256)

        claims := token.Claims.(jwt.MapClaims)
        claims["uid"] = user.ID
        claims["login"] = user.Login
        claims["exp"] = time.Now().Add(ttl).Unix()

        signedString, err := token.SignedString([]byte(s.secretKey))
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">return entity.Token(signedString), nil</span>
}

func (s JwtService) Parse(token entity.Token) (int64, error) <span class="cov8" title="1">{
        parsedToken, err := jwt.Parse(string(token), func(token *jwt.Token) (any, error) </span><span class="cov8" title="1">{
                return []byte(s.secretKey), nil
        }</span>)

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, jwt.ErrTokenExpired) </span><span class="cov8" title="1">{
                        return 0, common.ErrTokenHasExpired
                }</span>
                <span class="cov8" title="1">return 0, err</span>
        }

        <span class="cov8" title="1">if !parsedToken.Valid </span><span class="cov0" title="0">{
                return 0, common.ErrInvalidToken
        }</span>

        <span class="cov8" title="1">claims, ok := parsedToken.Claims.(jwt.MapClaims)
        if !ok </span><span class="cov0" title="0">{
                return 0, common.ErrInvalidToken
        }</span>
        <span class="cov8" title="1">uid, ok := claims["uid"]
        if !ok </span><span class="cov8" title="1">{
                return 0, common.ErrInvalidToken
        }</span>

        <span class="cov8" title="1">fuid, ok := uid.(float64)

        if !ok </span><span class="cov8" title="1">{
                return 0, common.ErrInvalidToken
        }</span>

        <span class="cov8" title="1">return int64(fuid), nil</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package order

import (
        "context"
        "time"

        "github.com/MxTrap/gophermart/internal/gophermart/common"
        "github.com/MxTrap/gophermart/internal/gophermart/entity"
        "github.com/MxTrap/gophermart/internal/utils"
        "github.com/MxTrap/gophermart/logger"
)

type storageService interface {
        Push(order entity.Order)
}

type orderRepository interface {
        Save(ctx context.Context, order entity.Order) error
        Find(ctx context.Context, number string) (entity.Order, error)
        GetAll(ctx context.Context, userID int64) ([]entity.Order, error)
}

type OrderService struct {
        log       *logger.Logger
        service   storageService
        orderRepo orderRepository
}

func NewOrderService(
        log *logger.Logger,
        service storageService,
        orderRepo orderRepository,
) *OrderService <span class="cov8" title="1">{
        return &amp;OrderService{
                log:       log,
                service:   service,
                orderRepo: orderRepo,
        }
}</span>

func (s *OrderService) SaveOrder(ctx context.Context, order entity.Order) error <span class="cov8" title="1">{
        log := s.log.With("op", "OrderService.SaveOrder")
        if !utils.IsOrderNumberValid(order.Number) </span><span class="cov8" title="1">{
                return common.ErrInvalidOrderNumber
        }</span>

        <span class="cov8" title="1">existingOrder, err := s.orderRepo.Find(ctx, order.Number)
        if err != nil </span><span class="cov8" title="1">{
                log.Error(err)
                return common.ErrInternalError
        }</span>

        <span class="cov8" title="1">if existingOrder.Number != "" </span><span class="cov8" title="1">{
                if existingOrder.UserID != order.UserID </span><span class="cov8" title="1">{
                        return common.ErrOrderRegisteredByAnother
                }</span>
                <span class="cov8" title="1">return common.ErrOrderAlreadyExist</span>
        }

        <span class="cov8" title="1">order.Status = entity.OrderNew
        order.UploadedAt = time.Now().UTC()

        err = s.orderRepo.Save(ctx, order)

        if err != nil </span><span class="cov8" title="1">{
                log.Error(err)
                return common.ErrInternalError
        }</span>

        <span class="cov8" title="1">s.service.Push(order)

        return nil</span>
}

func (s *OrderService) GetAll(ctx context.Context, userID int64) ([]entity.Order, error) <span class="cov8" title="1">{
        log := s.log.With("op", "OrderService.GetAll")
        orders, err := s.orderRepo.GetAll(ctx, userID)
        if err != nil </span><span class="cov8" title="1">{
                log.Error(err)
                return orders, err
        }</span>
        <span class="cov8" title="1">return orders, nil</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: order_worker_test.go

// Package services is a generated GoMock package.
package orderworker

import (
        context "context"
        reflect "reflect"

        entity "github.com/MxTrap/gophermart/internal/gophermart/entity"
        gomock "github.com/golang/mock/gomock"
)

// MockaccrualService is a mock of accrualService interface.
type MockaccrualService struct {
        ctrl     *gomock.Controller
        recorder *MockaccrualServiceMockRecorder
}

// MockaccrualServiceMockRecorder is the mock recorder for MockaccrualService.
type MockaccrualServiceMockRecorder struct {
        mock *MockaccrualService
}

// NewMockaccrualService creates a new mock instance.
func NewMockaccrualService(ctrl *gomock.Controller) *MockaccrualService <span class="cov8" title="1">{
        mock := &amp;MockaccrualService{ctrl: ctrl}
        mock.recorder = &amp;MockaccrualServiceMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockaccrualService) EXPECT() *MockaccrualServiceMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// GetOrderAccrual mocks base method.
func (m *MockaccrualService) GetOrderAccrual(number string) (entity.Order, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetOrderAccrual", number)
        ret0, _ := ret[0].(entity.Order)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetOrderAccrual indicates an expected call of GetOrderAccrual.
func (mr *MockaccrualServiceMockRecorder) GetOrderAccrual(number interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetOrderAccrual", reflect.TypeOf((*MockaccrualService)(nil).GetOrderAccrual), number)
}</span>

// Mockstorage is a mock of storage interface.
type Mockstorage struct {
        ctrl     *gomock.Controller
        recorder *MockstorageMockRecorder
}

// MockstorageMockRecorder is the mock recorder for Mockstorage.
type MockstorageMockRecorder struct {
        mock *Mockstorage
}

// NewMockstorage creates a new mock instance.
func NewMockstorage(ctrl *gomock.Controller) *Mockstorage <span class="cov8" title="1">{
        mock := &amp;Mockstorage{ctrl: ctrl}
        mock.recorder = &amp;MockstorageMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *Mockstorage) EXPECT() *MockstorageMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// Get mocks base method.
func (m *Mockstorage) Get(elemCount int) []entity.Order <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Get", elemCount)
        ret0, _ := ret[0].([]entity.Order)
        return ret0
}</span>

// Get indicates an expected call of Get.
func (mr *MockstorageMockRecorder) Get(elemCount interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Get", reflect.TypeOf((*Mockstorage)(nil).Get), elemCount)
}</span>

// Push mocks base method.
func (m *Mockstorage) Push(el entity.Order) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        m.ctrl.Call(m, "Push", el)
}</span>

// Push indicates an expected call of Push.
func (mr *MockstorageMockRecorder) Push(el interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Push", reflect.TypeOf((*Mockstorage)(nil).Push), el)
}</span>

// MockorderBalanceRepo is a mock of orderBalanceRepo interface.
type MockorderBalanceRepo struct {
        ctrl     *gomock.Controller
        recorder *MockorderBalanceRepoMockRecorder
}

// MockorderBalanceRepoMockRecorder is the mock recorder for MockorderBalanceRepo.
type MockorderBalanceRepoMockRecorder struct {
        mock *MockorderBalanceRepo
}

// NewMockorderBalanceRepo creates a new mock instance.
func NewMockorderBalanceRepo(ctrl *gomock.Controller) *MockorderBalanceRepo <span class="cov8" title="1">{
        mock := &amp;MockorderBalanceRepo{ctrl: ctrl}
        mock.recorder = &amp;MockorderBalanceRepoMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockorderBalanceRepo) EXPECT() *MockorderBalanceRepoMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// UpdateOrderBalance mocks base method.
func (m *MockorderBalanceRepo) UpdateOrderBalance(ctx context.Context, order entity.Order) error <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UpdateOrderBalance", ctx, order)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// UpdateOrderBalance indicates an expected call of UpdateOrderBalance.
func (mr *MockorderBalanceRepoMockRecorder) UpdateOrderBalance(ctx, order interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateOrderBalance", reflect.TypeOf((*MockorderBalanceRepo)(nil).UpdateOrderBalance), ctx, order)
}</span>
</pre>
		
		<pre class="file" id="file36" style="display: none">package orderworker

import (
        "context"
        "errors"
        "sync"
        "time"

        "github.com/MxTrap/gophermart/internal/gophermart/entity"
        "github.com/MxTrap/gophermart/logger"
)

type accrualService interface {
        GetOrderAccrual(number string) (entity.Order, error)
}

type storage interface {
        Push(el entity.Order)
        Get(elemCount int) []entity.Order
}

type orderBalanceRepo interface {
        UpdateOrderBalance(ctx context.Context, order entity.Order) error
}

type OrderWorkerService struct {
        log     *logger.Logger
        svc     accrualService
        storage storage
        repo    orderBalanceRepo
}

func NewOrderWorkerService(
        log *logger.Logger,
        svc accrualService,
        storage storage,
        repo orderBalanceRepo,
) *OrderWorkerService <span class="cov0" title="0">{
        return &amp;OrderWorkerService{
                log:     log,
                svc:     svc,
                storage: storage,
                repo:    repo,
        }
}</span>

type result struct {
        order entity.Order
        err   error
}

func (*OrderWorkerService) isTerminalStatus(status string) bool <span class="cov8" title="1">{
        return status == entity.OrderInvalid || status == entity.OrderProcessed
}</span>

func (s *OrderWorkerService) save(ctx context.Context, ch chan result) <span class="cov8" title="1">{
        go func() </span><span class="cov8" title="1">{
                for res := range ch </span><span class="cov8" title="1">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return</span>
                        default:<span class="cov8" title="1">
                                if res.err != nil </span><span class="cov8" title="1">{
                                        s.log.Error("failed to save ch: %v", res.err)
                                }</span>
                                <span class="cov8" title="1">err := s.repo.UpdateOrderBalance(ctx, res.order)
                                if err != nil || !s.isTerminalStatus(res.order.Status) </span><span class="cov8" title="1">{
                                        s.storage.Push(res.order)
                                }</span>
                        }
                }
        }()
}

func (s *OrderWorkerService) update(ctx context.Context, inputChan chan entity.Order) chan result <span class="cov8" title="1">{
        resultCh := make(chan result)

        go func() </span><span class="cov8" title="1">{
                defer close(resultCh)
                for order := range inputChan </span><span class="cov8" title="1">{
                        accrualOrder, err := s.svc.GetOrderAccrual(order.Number)
                        if accrualOrder.Status == order.Status </span><span class="cov8" title="1">{
                                err = errors.New("order has already been processed")
                        }</span>
                        <span class="cov8" title="1">if err == nil </span><span class="cov8" title="1">{
                                accrualOrder.UserID = order.UserID
                                accrualOrder.Number = order.Number
                        }</span>

                        <span class="cov8" title="1">select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return</span>
                        case resultCh &lt;- result{accrualOrder, err}:<span class="cov8" title="1"></span>
                        }
                }

        }()

        <span class="cov8" title="1">return resultCh</span>
}

func (*OrderWorkerService) generate(ctx context.Context, input []entity.Order) chan entity.Order <span class="cov8" title="1">{
        inputCh := make(chan entity.Order)

        go func() </span><span class="cov8" title="1">{
                defer close(inputCh)

                for _, data := range input </span><span class="cov8" title="1">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov8" title="1">
                                return</span>
                        case inputCh &lt;- data:<span class="cov8" title="1"></span>
                        }
                }
        }()

        <span class="cov8" title="1">return inputCh</span>
}

func (s *OrderWorkerService) fanOut(ctx context.Context, input chan entity.Order) []chan result <span class="cov8" title="1">{
        numWorkers := 5

        channels := make([]chan result, numWorkers)

        for i := 0; i &lt; numWorkers; i++ </span><span class="cov8" title="1">{
                resultCh := s.update(ctx, input)
                channels[i] = resultCh
        }</span>

        <span class="cov8" title="1">return channels</span>
}

func (*OrderWorkerService) fanIn(ctx context.Context, results []chan result) chan result <span class="cov8" title="1">{
        finalCh := make(chan result)

        var wg sync.WaitGroup

        for _, ch := range results </span><span class="cov8" title="1">{
                chClosure := ch

                wg.Add(1)

                go func() </span><span class="cov8" title="1">{
                        defer wg.Done()
                        for data := range chClosure </span><span class="cov8" title="1">{
                                select </span>{
                                case &lt;-ctx.Done():<span class="cov0" title="0">
                                        return</span>
                                case finalCh &lt;- data:<span class="cov8" title="1"></span>
                                }
                        }
                }()
        }

        <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                wg.Wait()
                close(finalCh)
        }</span>()

        <span class="cov8" title="1">return finalCh</span>

}

func (s *OrderWorkerService) Run(ctx context.Context) <span class="cov8" title="1">{
        const jobNum = 5
        const updateDelay = time.Second * 5

        go func(ctx context.Context) </span><span class="cov8" title="1">{
                for </span><span class="cov8" title="1">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return</span>
                        default:<span class="cov8" title="1">
                                orders := s.storage.Get(jobNum)
                                inputCh := s.generate(ctx, orders)
                                channels := s.fanOut(ctx, inputCh)
                                resultCh := s.fanIn(ctx, channels)
                                s.save(ctx, resultCh)</span>
                        }

                        <span class="cov8" title="1">time.Sleep(updateDelay)</span>
                }
        }(ctx)
}
</pre>
		
		<pre class="file" id="file37" style="display: none">package storage

import (
        "github.com/MxTrap/gophermart/internal/gophermart/entity"
)

type Storage struct {
        queue *[]entity.Order
}

func NewStorageService() *Storage <span class="cov8" title="1">{
        return &amp;Storage{
                queue: &amp;[]entity.Order{},
        }
}</span>

func (s *Storage) Push(el entity.Order) <span class="cov8" title="1">{
        *s.queue = append(*s.queue, el)
}</span>

func (s *Storage) Get(elemCount int) []entity.Order <span class="cov8" title="1">{
        self := *s.queue
        var el []entity.Order
        if len(self) == 0 </span><span class="cov8" title="1">{
                return el
        }</span>
        <span class="cov8" title="1">if len(self) &gt; elemCount </span><span class="cov8" title="1">{
                el, *s.queue = self[:elemCount], self[elemCount:]
                return el
        }</span>

        <span class="cov8" title="1">el, *s.queue = *s.queue, []entity.Order{}

        return el</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">package withdrawal

import (
        "context"
        "time"

        "github.com/MxTrap/gophermart/internal/gophermart/common"
        "github.com/MxTrap/gophermart/internal/gophermart/entity"
        "github.com/MxTrap/gophermart/internal/utils"
        "github.com/MxTrap/gophermart/logger"
)

type withdrawer interface {
        Withdraw(ctx context.Context, userID int64, withdrawal entity.Withdrawal) error
}

type getter interface {
        GetAll(ctx context.Context, userID int64) ([]entity.Withdrawal, error)
}

type WithdrawalService struct {
        log        *logger.Logger
        withdrawer withdrawer
        getter     getter
}

func NewWithdrawalService(log *logger.Logger, withdrawer withdrawer, getter getter) *WithdrawalService <span class="cov8" title="1">{
        return &amp;WithdrawalService{
                log:        log,
                withdrawer: withdrawer,
                getter:     getter,
        }
}</span>

func (s *WithdrawalService) Withdraw(ctx context.Context, userID int64, withdrawal entity.Withdrawal) error <span class="cov8" title="1">{
        log := s.log.With("op", "WithdrawalService.Withdraw")
        if !utils.IsOrderNumberValid(withdrawal.Order) </span><span class="cov8" title="1">{
                return common.ErrInvalidOrderNumber
        }</span>

        <span class="cov8" title="1">withdrawal.ProcessedAt = time.Now().UTC()
        err := s.withdrawer.Withdraw(ctx, userID, withdrawal)
        if err != nil </span><span class="cov8" title="1">{
                log.Error(err)
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (s *WithdrawalService) GetAll(ctx context.Context, userID int64) ([]entity.Withdrawal, error) <span class="cov8" title="1">{
        log := s.log.With("op", "WithdrawalService.GetAll")
        var withdrawals []entity.Withdrawal

        withdrawals, err := s.getter.GetAll(ctx, userID)
        if err != nil </span><span class="cov8" title="1">{
                log.Error(err)
                return withdrawals, err
        }</span>

        <span class="cov8" title="1">return withdrawals, nil</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package utils

import (
        "path/filepath"
        "runtime"
)

var (
        _, b, _, _ = runtime.Caller(0)
)

func GetProjectPath() string <span class="cov0" title="0">{
        return filepath.Join(filepath.Dir(b), "../..")
}</span>
</pre>
		
		<pre class="file" id="file40" style="display: none">package utils

import "strconv"

func IsOrderNumberValid(number string) bool <span class="cov8" title="1">{
        if number == "" </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">var sum int
        parity := len(number) % 2
        for i := range len(number) </span><span class="cov8" title="1">{
                digit, _ := strconv.Atoi(string(number[i]))
                if i%2 == parity </span><span class="cov8" title="1">{
                        digit *= 2
                        if digit &gt; 9 </span><span class="cov8" title="1">{
                                digit -= 9
                        }</span>
                }
                <span class="cov8" title="1">sum += digit</span>
        }
        <span class="cov8" title="1">return sum%10 == 0</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">package logger

import (
        "go.uber.org/zap"
)

type Logger struct {
        *zap.SugaredLogger
}

func NewLogger() *Logger <span class="cov8" title="1">{
        logger, _ := zap.NewProduction()
        logger = logger.WithOptions(zap.WithCaller(false), zap.AddStacktrace(zap.FatalLevel))
        sugar := logger.Sugar()
        return &amp;Logger{
                sugar,
        }
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
